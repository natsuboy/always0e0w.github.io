<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>播放历史架构设计</title>
    <link href="/posts/270fbf23/"/>
    <url>/posts/270fbf23/</url>
    
    <content type="html"><![CDATA[<h1 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h1><p>功能截图：</p><img src="/posts/270fbf23/view-history.png" class="" title="播放历史功能截图"><ul><li>变更功能：添加记录、删除记录、清空历史等。</li><li>读取功能：按照时间线返回topN、获取某个视频的观看进度信息等。</li><li>其他功能：暂停&#x2F;回复记录、首次观看某视频触发某逻辑（比如增加经验）。</li></ul><p>特点：观看历史记录类型的业务，是一个极高TPS写入（端上需要定期上报观看进度，比如5s一次）和QPS读取的业务（每次观看视频的时候都要获取该视频的观看进度）。</p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><img src="/posts/270fbf23/history-system-design.png" class="" title="架构设计"><div class="note note-info">            <p>离线用户在APP本地保留历史记录数据。</p>          </div><ul><li>BFF：app-interface、history。播放历史BFF层，app-interface服务处理来自外部用户的读请求，依赖其他如稿件服务、漫画服务等来组装完整的面向历史记录业务需要的数据，同时接受来自内部其他服务的写请求，通常都是业务方自己进行业务ID的判定，然后投递到BFF的history服务的写接口中。</li><li>Service：hostory-service，服务层，去除平台业务逻辑的基础服务，专注于历史记录数据的持久化上（因为对于播放类业务，BFF专注于平台业务数据组织，service负责数据的CRUD操作。播放进度是需要高频上报同步的，需要考虑性能优化。）这里采用的是<code>write-back</code>的思路，将数据先同步写入分布式缓存，写异步写回数据库。</li><li>Job：history-job，消费上游生产的Kafka消息，利用消息队列的堆积能力，对于存储层的差速（消费能力跟不上生产速度时），可以进行一定的数据反压（即暂时堆积在Kafka中），配合上游service批量打包过来的数据来进行持久化。</li><li>Upstream：some-app、some-api，整个历史服务还会被一些外部gRPC服务所依赖，这些上游服务使用历史服务的写接口把自己业务的数据进行持久化。</li></ul><p>该历史服务中最重要的设计，就是通过批量打包来聚合数据。将高频、密集的写请求先写入缓存，然后批量消费来减少对存储的直接压力。</p><h2 id="history-service"><a href="#history-service" class="headerlink" title="history-service"></a>history-service</h2><p>该服务专注于处理历史记录的数据。</p><p>写操作的核心逻辑：用户观看的视频、漫画等，带有进度信息的数据，对于同一个用户来说，在一个时间窗口内（比如1分钟），实际上只有最后一次的进度数据是有效的，即<a href="https://stackoverflow.com/questions/26890288/what-is-last-write-wins">last write wins</a>，高频的用户端同步逻辑，只需要对最后一次的数据持久化即可。我们可以在服务进程的内存中，定时&#x2F;定量聚合不同用户的同一个对象的最后一个进度（比如在<code>Golang</code>中采用定时器+<code>map</code>实现），然后再投递到Kafka中来进行削峰处理。但同时我们需要保证用户数据可以被实时观察到，不能出现上报进度后，需要等一会才能同步到。所以我们可以在内存中聚合数据后，同时实时写入到<code>Redis</code>中。这样就既保证了实时性，又避免了海量的写入冲击存储。</p><div class="note note-warning">            <p>写入到Redis中的数据，不能无限制的存储，需要有截断逻辑（比如超过一定大小后将旧数据删除一部分）。<br>所以Redis中的数据不一定是用户历史记录的完整数据。</p>          </div><p>数据流：history-service -&gt; 实时写Redis -&gt; history-service进程内存聚合 -&gt; 定时&#x2F;定量写Kafka -&gt; history-job -&gt; DB。</p><img src="/posts/270fbf23/history-service.png" class="" title="history-service"><div class="note note-warning">            <p>Kafka是为高吞吐设计的，而高频写入并不是其最擅长的，所以在内存聚合后还需要使用分片算法来将数据打散到多个partition上（比如采用<code>uid%100</code>的算法）。</p>          </div><p>读操作的核心逻辑：先从Redis读取，如果命中的数据不足，则从存储中读取。这里可以采用cache-aside的模式回写缓存，但不推荐，因为未命中缓存的一般属于比较旧的数据，这种数据对应到用户上属于低频行为。历史记录数据通常是按照时间线来组织，可以使用时间戳作为游标来进行瀑布流加载或者翻页。</p><h1 id="history-job"><a href="#history-job" class="headerlink" title="history-job"></a>history-job</h1><p>职责：从Kafka消费history-service聚合好的用户数据，批量持久化。</p><p>为了节约传输过程中的开销，以及history-service服务进程的内存使用，投递到Kafka的数据只有uid和对应聚合到的观看对象ID列表，以达到最小化Kafka存储和网络传输成本的目的。也正因为如此，所以history-job拿到的数据是不完整的，所以还需要额外从Redis中按照观看对象ID取出对应的数据，再持久化。</p><h1 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>这里以使用<code>HBase</code>为例：</p><img src="/posts/270fbf23/hbase.png" class="" title="数据库设计(HBase)"><p>数据写入: PUT mid, values，只需要写入到 column_family 的 info 列簇，rowkey 使用用户 id md5 以后的头两位 + 用户，避免 rowkey 热点密集到一个 region 中，导致写&#x2F;读热点。 对于 column_family: info，存储一个列 obj_id + obj_type，例如 稿件业务:1、稿件ID: 100，100_1 作为列名，对于 value 使用 protobuf 序列化一个结构体接入。所以只需要单次更新 kv store。另外我们使用 HBase TTL 的能力，只需要保存90天的用户数据即可。(删除同理)<br>数据读取: 列表获取为 GET mid，直接获取1000条，在内存中排序和翻页。点查 GET mid columns，在茫茫多视频查看当前视频的阅读进度，cache miss 会非常严重，虽然支持点查，但是对于上层 cache miss 后，不再回源请求 HBase。</p><h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><p>以<code>Redis</code>为例：</p><img src="/posts/270fbf23/redis.png" class="" title="缓存设计(Redis)"><p>数据写入: 每次产生的历史数据，需要立马更新 redis，使用 sorted set 基于时间排序的列表，member 为业务 ID。同时存储一份数据到 redis string 中，使用 protobuf 序列化完整的数据内容。为了避免 redis 中单个用户数据无限增长，需要超过一定量后对数据进行截断。</p><p>数据读取: 分为两个场景，一个是历史页面，这时候使用 sorted set，排序查找即可，拿到列表后，mget 批量获取 history_content 内容。另外一个是点查进度，比如我们点击进入一个视频详情页，这时候直接查找 history_content 进行点查，不再回源 HBase，因为命中率太低（没看过的都查不到记录）。</p><h1 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h1><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>经过 BFF history 的流量 per-request 都会发送给 history-service，我们最容易想到的优化就是聚合上移来减少发送给下游的 rpc。但是按照 mid region sharding 的思路非常具有业务的耦合性，所以不应该把逻辑上移，而只是数据上移，所以可以考虑简单 batch put 请求，做一个无逻辑的数据聚合再发送给 history-service，这样可以大大的减少内网的流量，节约资源。</p><p>我们发现经过 API Gateway 的流量都会触发高频的 per-rpc auth，给内网的 identify-service 带来了不少压力。我们认为大部分历史行为通过心跳的方式同步进度，为何不连接一个长连接，长连接服务再握手后先进行用户级的身份验证，之后维持身份信息，而不是每次发送 request 都进行验证，这样可以大大减少内网的 identify-service 的流量。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>用户首次触发的行为，需要发送消息给下游系统进行触发其他奖励等。如何减少这类一天只用一次的标记位缓存请求？<br>使用 in-process localcache，只有高频的用户访问，带来的收益就越大，我们很容易想到使用 LRU 维护这个集合，但用户分布很广，很难覆盖，命中率很低。</p><p>越源头解决架构问题，通常越简单，效率越高。</p><p>我们在写操作(高频请求)中，把当前的 flag 返回到 API 协议中，作为一个日期值，客户端保存到本地，下次请求的时候带上，如果发现该值在，获取以后直接使用不再请求缓存，例如: 2021-1-1，发现当前时间还是2021-1-1，直接不再请求 redis，如果发现当前时间是2021-1-2，需要触发一次 redis 访问，返回新的 flag 到客户端，这样把状态广播同步到任何其他设备，可以大大减少判定缓存。</p><p>实现成本在于，你认为的代价高低。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://u.geekbang.org/lesson/68?article=333628">毛剑-播放历史架构设计</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>评论系统架构设计</title>
    <link href="/posts/5426ec20/"/>
    <url>/posts/5426ec20/</url>
    
    <content type="html"><![CDATA[<h1 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h1><img src="/posts/5426ec20/comments.jpg" class="" title="评论功能示例"><p>架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。</p><p>评论系统，我们往小里做就是视频评论系统，往大里做就是评论平台，可以接入各种业务形态。</p><p>需求功能点：</p><ul><li>发布评论: 支持回复楼层、楼中楼。</li><li>读取评论: 按照时间、热度排序。</li><li>删除评论: 用户自己删除、楼主&#x2F;管理员删除。</li><li>管理评论: 作者置顶、后台运营管理(搜索、删除、审核等)。</li></ul><p><strong>在动手设计前，反复思考，真正编码的时间只有5%。</strong></p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><img src="/posts/5426ec20/comment-system-arch.png" class="" title="架构设计"><p>模块说明：</p><ul><li>comment: 负责对复杂的评论业务进行服务编排（比如访问账号服务进行等级判断），同时在<code>BFF</code>层面向移动端或web场景来设计API。通过这一层的抽象把评论本身的内容列表处理（加载、分页、排序等）进行了隔离，关注在业务平台化逻辑上。</li><li>comment-service: 服务层，去平台业务的逻辑，专注在评论功能的API实现上，比如发布评论、读取评论、删除评论等，关注在稳定性、可用性上，从而让上游可以灵活的组织逻辑把基础能力和业务能力剥离。</li><li>comment-job: 利用消息队列进行流量削峰。当遇到密集写的场景时，服务的瓶颈大概率发生在有状态的一层（比如DB），所以在此场景下可以使用消息队列（比如Kafka）的堆积能力进行流量削峰。但是要注意，这种方式会导致用户看到的数据可能会有延迟，严格的实时场景需要另寻他法。</li><li>comment-admin: 评论管理平台，按照安全等级划分服务，尤其要对运营平台进行划分，它们会共享服务层的存储（MySQL、Redis）。运营体系的数据大多都是检索，我们可以使用<code>[canal](https://github.com/alibaba/canal)</code>同步到<code>ES</code>中，从而使用<code>ES</code>独立作为运营平台的数据源，这样运营平台的查询压力就下放给了独立的<code>fulltext search</code>系统（即<code>ES</code>）。</li><li>account-service &amp; filter-service: 整个评论服务还会依赖一些外部的<code>gRPC</code>服务，统一的平台业务逻辑在<code>comment BFF</code>层收敛。<code>account-service</code>和<code>filter-service</code>就是其外部依赖的账号服务和敏感词过滤服务。</li></ul><p>回源：当comment-service读取未命中缓存时，先从DB捞所需数据，然后生产一条cache rebuild的指令到消息队列，再由消息队列的消费端job进行缓存回填。</p><p>流量路径：请求 -&gt; API网关(如envoy) -&gt; BFF(服务编排) -&gt; 账号服务&amp;敏感词过滤等BFF的第三方依赖 -&gt; comment-service -&gt; 消息队列 -&gt; comment-job -&gt; 存储</p><div class="note note-info">            <p>架构设计应该简单而不简约。<br>架构设计等同于数据设计，梳理清楚数据的走向和逻辑，尽量避免环形依赖、数据双向请求等。—— by 毛剑</p>          </div><h2 id="comment-service"><a href="#comment-service" class="headerlink" title="comment-service"></a>comment-service</h2><p>专注于评论数据的处理。</p><p>如果comment-service和comment服务在同一层，那么业务将和评论的基础功能耦合在一起实现，后续将非常不利于迭代，并且在业务功能迭代的过程中可能会导致评论的基础功能出现问题。</p><p>读的核心逻辑：使用Cache-Aside模式，先读取缓存，缓存未命中时再读取存储。对于缓存重建逻辑，比较直接的做法是使用 read ahead 的思路，即预读，当用户访问第一页的时候，我们假定用户大概率会访问第二页，所以缓存会提前加载一部分，避免频繁触发cache miss。但是当缓存抖动时，这种方式特别容易引起<code>MySQL</code>集群的<a href="https://zh.wikipedia.org/wiki/%E6%83%8A%E7%BE%A4%E9%97%AE%E9%A2%98">thundering herd</a>现象，从而导致触发大量cache rebuild，再加上使用了read ahead的预加载模式，就很容易导致业务服务OOM（因为业务服务的内存中会突然增加大量从DB读取到的数据）。所以这里的架构中使用了回源的逻辑，使用消息队列将逻辑进行异步化的处理，对于当前请求只返回<code>MySQL</code>中的部分数据即可。</p><p>写的核心逻辑：当类似”明星出轨“等热点事件发生时，写和读相比较，写操作可以认为是透传到存储层的，系统的瓶颈往往也是在存储层（或有状态层）。对于写操作的设计，我们可以认为刚发布的评论有极短的延迟（毫秒级）对于用户来说是可接受的，所以可以把对存储的直接冲击下放到消息队列，按照消息反压的思路，即如果存储latency升高，消费能力就下降，自然消息容易堆积，以此来保证系统始终以最大能力消费。</p><p>对于消费到的消息如何保证顺序的问题，以消息队列使用<code>Kafka</code>为例，<code>Kafka</code>有<code>partition</code>的概念，一个<code>topic</code>由一组<code>partition</code>组成，所以<code>Kafka</code>的吞吐模型理解为”全局并行、局部串行“的生产消费模式。因此对于入队的消息，可以按照<code>hash(评论所属主题的ID)%partition个数</code>的方式进行分发，将某个主题的所有评论全部丢到一个统一的<code>partition</code>中进行处理，就可以保证评论的顺序了。（同样的，回源消息也是类似的思路）</p><div class="note note-danger">            <p>思考：如果<code>partition</code>的个数中途变了怎么办？</p>          </div><img src="/posts/5426ec20/comment-read.png" class="" title="读&amp;写评论的逻辑"><h2 id="comment-admin"><a href="#comment-admin" class="headerlink" title="comment-admin"></a>comment-admin</h2><img src="/posts/5426ec20/mysql2es.png" class="" title="mysql -&gt; es"><p><code>MySQL</code>的<code>binlog</code>数据被<code>canal</code>中间件流式消费，获取到业务的原始CRUD操作，通过回放录入到<code>ES</code>中。但是<code>ES</code>中的数据最终是面向运营体系提供服务能力的，需要检索的数据维度比较多，所以在入<code>ES</code>之前需要做一个异构的<code>Joiner</code>，把单表变宽预处理好join逻辑，然后再导入<code>ES</code>中。</p><p>一般来说，运营后台的检索条件都是组合使用的，使用<code>ES</code>的好处是可以避免依赖<code>MySQL</code>来做多条件检索，同时<code>MySQL</code>毕竟是<code>OLTP</code>面向线上联机事务处理的。通过冗余数据的方式，使用其他引擎来实现。</p><h2 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h2><p>comment服务作为BFF，是面向端、面向平台、面向业务组合的服务。所以平台扩展的能力，我们都在comment服务来实现，以统一的接口形式提供平台化的能力。</p><ul><li>依赖其他gRPC服务，整合统一平台侧的逻辑（比如发布评论时对用户等级的判定）</li><li>直接向端上提供接口，提供数据的读写接口，甚至可以整合端上，提供统一的端上SDK</li><li>需要对非核心依赖的gRPC服务进行降级</li></ul><h1 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>表结构：</p><img src="/posts/5426ec20/dbtable.png" class="" title="数据库表"><ul><li>comment_subject_n：主题（评论所属的实体）表</li><li>comment_content_m：评论内容表，包含评论的实际内容</li><li>comment_index_k：评论楼层的索引组织表，不包含评论的实际内容</li></ul><p>comment_content表中的comment_id与comment_index中的id字段是一一对应的关系，这里面包含的设计思想：</p><ul><li>MySQL的表都有主键，是物理组织形式存放的，comment_content表没有使用自增id作为主键，是为了通过comment_id查询评论内容时减少一次回表操作，直接使用comment_id作为主键查找可以直接查询到评论对应的信息。</li><li>索引、内容分离，方便<code>MySQL</code>的<code>data page</code>缓存更多行数据，如果和content耦合，可能会导致更大的IO。长远来看，content的信息可以使用<code>K/V</code>类型的存储。</li></ul><p>数据写入：在同一个事务中更新comment_subject、comment_index、comment_content三张表，其中comment_content属于非强一致性考虑的。也可以先写入comment_content，再在另一个事务中更新其他的表(comment_subject-&gt;comment_index)。即便comment_content先成功，后续其他表更新失败也不过是多存在一条ghost数据而已。</p><p>数据读取：基于<code>obj_id</code>和<code>obj_type</code>在<code>comment_index</code>中找到评论列表（ <code>WHERE root=0 ORDER BY floor</code>）。然后再根据<code>comment_index</code>的<code>id</code>字段从<code>comment_content</code>中将评论的内容获取到。</p><p>这里假设产品形态只支持二级列表（即对评论的回复只有两级：主评论和二级评论，不能无限嵌套，如图1），因此只需要迭代查询两次即可。对于嵌套层次多的产品形态，可以通过二次点击支持。</p><div class="note note-info">            <p>思考：是否可以用Graph存储？DGraph、HugeGraph类似的图存储思路。</p>          </div><h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><p>基于Redis的设计：</p><img src="/posts/5426ec20/cache.png" class="" title="缓存设计"><ul><li>comment_subject_cache：主题的缓存，value使用<code>protobuf</code>序列化的方式存入（比json序列化的体积要小）。</li><li>comment_index_cache：使用Redis的sorted set来缓存评论索引。</li><li>comment_content_cache：缓存评论内容。</li></ul><h1 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h1><h2 id="Singleflight"><a href="#Singleflight" class="headerlink" title="Singleflight"></a>Singleflight</h2><p>对于热门的主题，如果存在缓存穿透的情况，会导致大量的同进程、跨进程的数据回源到存储层，可能会引起存储过载的情况，如何只交给同进程内，一个人去做加载存储?</p><p>使用归并回源的思路：<a href="https://pkg.go.dev/golang.org/x/sync/singleflight">https://pkg.go.dev/golang.org/x/sync/singleflight</a></p><p>同进程只交给一个人去获取<code>MySQL</code>数据，然后批量返回。同时这个 lease owner 投递一个 kafka 消息，做 index cache 的 recovery 操作。这样可以大大减少<code>MySQL</code>的压力，以及大量透穿导致的密集写 kafka 的问题。</p><p>更进一步的，后续连续的请求，仍然可能会短时 cache miss，我们可以在进程内设置一个 short-lived flag，标记最近有一个人投递了 cache rebuild 的消息，直接 drop。</p><div class="note note-info">            <p>思考：这里不建议使用分布式锁，可以思考下为什么。</p>          </div><h2 id="热点"><a href="#热点" class="headerlink" title="热点"></a>热点</h2><p>流量热点是因为突然热门的主题，被高频次的访问，因为底层的 cache 设计，一般是按照主题 key 进行一致性 hash 来进行分片，但是热点 key 一定命中某一个节点，这时候 remote cache 可能会变为瓶颈，因此将  remote cache 升级为 local cache 是有必要的，我们一般使用单进程自适应发现热点的思路，附加一个短时的 ttl local cache，就可以在进程内吞掉大量的读请求。</p><p>可以在内存中使用 hashmap 统计每个 key 的访问频次（注意控制map的大小，避免OOM），这里可以使用滑动窗口统计，即每个窗口中，维护一个 hashmap，之后统计所有未过期的 bucket，汇总所有 key 的数据。</p><p>之后使用小堆计算 TopK 的数据，自动进行热点识别。</p><img src="/posts/5426ec20/circular-array.png" class="" title="环形数组"><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://u.geekbang.org/lesson/68?article=323030">Go进阶训练营 - 评论系统架构设计</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GORM</title>
    <link href="/posts/dca1779e/"/>
    <url>/posts/dca1779e/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是GORM？"><a href="#什么是GORM？" class="headerlink" title="什么是GORM？"></a>什么是GORM？</h1><p><code>ORM</code>让你的数据库里面的表结构变成你的代码中定义的数据结构（比如<code>Golang</code>中的结构体），从而做到代码结构即为数据库结构，代码行为即为数据库行为。</p><h1 id="GORM中的约定"><a href="#GORM中的约定" class="headerlink" title="GORM中的约定"></a>GORM中的约定</h1><p><code>GORM</code>倾向于约定，而不是配置。默认情况下，<code>GORM</code>使用<code>ID</code>作为主健，使用结构体名的蛇形复数(如：OrderRecord -&gt; order_records)作为表名，字段名的蛇形作为列名，并使用<code>CreatedAt(created_at)</code>、<code>UpdatedAt(updated_at)</code>字段追踪创建时间和更新时间。</p><p>如果要使用<code>ID</code>之外的其他字段作为主键，可以通过添加<code>primaryKey</code>标签进行指定：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 将 UUID 设为主键</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int64</span><br>UUID <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过将多个字段设置为主键，可以创建复合主键：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>ID           <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>LanguageCode <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>Code         <span class="hljs-type">string</span><br>Name         <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>默认情况下，整型字段启用了<code>AutoIncrement</code>，可以通过如下方式对其禁用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>CategoryID <span class="hljs-type">uint64</span> <span class="hljs-string">`gorm:&quot;primaryKey;autoIncrement:false&quot;`</span><br>TypeID     <span class="hljs-type">uint64</span> <span class="hljs-string">`gorm:&quot;primaryKey;autoIncrement:false&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure>          </div><h1 id="自定义表名"><a href="#自定义表名" class="headerlink" title="自定义表名"></a>自定义表名</h1><p>当默认约定的表名不满足需求时，可以通过实现<code>Tabler</code>接口来自定义表名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Tabler <span class="hljs-keyword">interface</span> &#123;<br>TableName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 对 User 结构体实现 Tabler 接口将 User 的表名重写为 profiles </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(User)</span></span> TableName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;profiles&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><code>TableName</code>方法不支持动态的表名，它会被缓存下来以便后续使用。如果需要动态获取表名，可以使用如下方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UserTable</span><span class="hljs-params">(user User)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> *gorm.DB &#123;<br>        <span class="hljs-comment">// 如果是管理员使用 admin_users 表</span><br><span class="hljs-keyword">if</span> user.Admin &#123;<br><span class="hljs-keyword">return</span> tx.Table(<span class="hljs-string">&quot;admin_users&quot;</span>)<br>        <span class="hljs-comment">// 否则使用 users 表</span><br>&#125;<br><span class="hljs-keyword">return</span> tx.Table(<span class="hljs-string">&quot;users&quot;</span>)<br>&#125;<br>&#125;<br><br>db.Scopes(UserTable(user)).Create(&amp;user)<br></code></pre></td></tr></table></figure>          </div><h1 id="临时指定表名"><a href="#临时指定表名" class="headerlink" title="临时指定表名"></a>临时指定表名</h1><p>可以使用<code>Table</code>方法临时指定表名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据 User 的字段创建名为 deleted_users 的表</span><br>db.Table(<span class="hljs-string">&quot;deleted_users&quot;</span>).AutoMigrate(&amp;User&#123;&#125;)<br><br><span class="hljs-comment">// 从另一张表查询数据（比如该表可能是主表的影子表）</span><br><span class="hljs-keyword">var</span> deletedUsers []User<br>db.Table(<span class="hljs-string">&quot;deleted_users&quot;</span>).Find(&amp;deletedUsers)<br><span class="hljs-comment">// SELECT * FROM deleted_users;</span><br><br>db.Table(<span class="hljs-string">&quot;deleted_users&quot;</span>).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;jinzhu&quot;</span>).Delete(&amp;User&#123;&#125;)<br><span class="hljs-comment">// DELETE FROM deleted_users WHERE name = &#x27;jinzhu&#x27;;</span><br></code></pre></td></tr></table></figure><h1 id="自定义列名"><a href="#自定义列名" class="headerlink" title="自定义列名"></a>自定义列名</h1><p>当列名的默认规则不满足需求时，可以使用<code>gorm:&quot;column:列名&quot;</code>的方式手动指定列名，示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>AnimalID <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:beast_id&quot;`</span>         <span class="hljs-comment">// 将列名设为 `beast_id`</span><br>Birthday time.Time <span class="hljs-string">`gorm:&quot;column:day_of_the_beast&quot;`</span> <span class="hljs-comment">// 将列名设为 `day_of_the_beast`</span><br>Age      <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:age_of_the_beast&quot;`</span> <span class="hljs-comment">// 将列名设为 `age_of_the_beast`</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h1><p><code>Scopes</code>(作用域)允许你复用通用的逻辑，不过这种通用逻辑的函数签名需是<code>func(*gorm.DB) *gorm.DB</code>。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AmountGreaterThan1000</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> db.Where(<span class="hljs-string">&quot;amount &gt; ?&quot;</span>, <span class="hljs-number">1000</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PaidWithCreditCard</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> db.Where(<span class="hljs-string">&quot;pay_mode_sign = ?&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PaidWithCod</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> db.Where(<span class="hljs-string">&quot;pay_mode_sign = ?&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">OrderStatus</span><span class="hljs-params">(status []<span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> db.Where(<span class="hljs-string">&quot;status IN (?)&quot;</span>, status)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查找所有金额大于 1000 的信用卡订单</span><br>db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&amp;orders)<br><br><span class="hljs-comment">// 查找所有金额大于 1000 的 COD 订单</span><br>db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&amp;orders)<br><br><span class="hljs-comment">// 查找所有金额大于1000 的已付款或已发货订单</span><br>db.Scopes(AmountGreaterThan1000, OrderStatus([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;paid&quot;</span>, <span class="hljs-string">&quot;shipped&quot;</span>&#125;)).Find(&amp;orders)<br></code></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Paginate</span><span class="hljs-params">(r *http.Request)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br>page, _ := strconv.Atoi(r.Query(<span class="hljs-string">&quot;page&quot;</span>))<br><span class="hljs-keyword">if</span> page == <span class="hljs-number">0</span> &#123;<br>page = <span class="hljs-number">1</span><br>&#125;<br><br>pageSize, _ := strconv.Atoi(r.Query(<span class="hljs-string">&quot;page_size&quot;</span>))<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> pageSize &gt; <span class="hljs-number">100</span>:<br>pageSize = <span class="hljs-number">100</span><br><span class="hljs-keyword">case</span> pageSize &lt;= <span class="hljs-number">0</span>:<br>pageSize = <span class="hljs-number">10</span><br>&#125;<br><br>offset := (page - <span class="hljs-number">1</span>) * pageSize<br><span class="hljs-keyword">return</span> db.Offset(offset).Limit(pageSize)<br>&#125;<br>&#125;<br><br>db.Scopes(Paginate(r)).Find(&amp;users)<br>db.Scopes(Paginate(r)).Find(&amp;articles)<br></code></pre></td></tr></table></figure><h1 id="钩子-Hook"><a href="#钩子-Hook" class="headerlink" title="钩子(Hook)"></a>钩子(Hook)</h1><p><code>Hook</code>是在创建、查询、更新、删除等操作之前、之后调用的函数。</p><p>如果您已经为模型定义了指定的方法，它会在创建、更新、查询、删除时自动被调用。如果任何回调返回错误，<code>GORM</code>将停止后续的操作并回滚事务。</p><p>钩子方法的函数签名应该是<code>func(*gorm.DB) error</code>。</p><p>一个遇到问题的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>dsn = <span class="hljs-string">&quot;user:password@tcp(127.0.0.1:3306)/database?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Test <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint64</span><br>Text <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Test)</span></span> BeforeCreate(db *gorm.DB) <span class="hljs-type">error</span> &#123;<br>t.Text = <span class="hljs-string">&quot;[before] &quot;</span> + t.Text<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Test)</span></span> AfterCreate(db *gorm.DB) <span class="hljs-type">error</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;after create&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db, err := gorm.Open(mysql.New(mysql.Config&#123;<br>DSN: dsn,<br>&#125;))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>table := &amp;Test&#123;&#125;<br><span class="hljs-keyword">if</span> !db.Migrator().HasTable(table) &#123;<br>err = db.AutoMigrate(table)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建test表成功&quot;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>table.Text = <span class="hljs-string">&quot;text&quot;</span><br>err = db.Create(table).Error<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;插入成功&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>注意⚠️：不要滥用钩子函数，否则会造成不可预测的性能影响！</p>          </div><h1 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h1><p>当默认的<code>logger</code>不满足需求时，可以通过自定义<code>logger</code>的配置来达到目的。比如如下例子是结合<code>zap</code>将<code>gorm</code>的日志写入到日志文件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;go.uber.org/zap&quot;</span><br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm/logger&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>dsn = <span class="hljs-string">&quot;root:password@tcp(127.0.0.1:3306)/gorm_test?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Test <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint64</span><br>Text <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>writer, f, err := zap.Open(<span class="hljs-string">&quot;~/GoProjects/gorm-test/test.log&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> f()<br>myLogger := logger.New(<br>log.New(writer, <span class="hljs-string">&quot;\r\n&quot;</span>, log.LstdFlags), <span class="hljs-comment">// 这里将 writer 传入来修改gorm写日志的目标</span><br>logger.Config&#123;<br>LogLevel:                  logger.Info, <span class="hljs-comment">// 将日志级别调整为 info 级别</span><br>IgnoreRecordNotFoundError: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 忽略记录不存在的错误</span><br>&#125;,<br>)<br>db, err := gorm.Open(<br>mysql.New(mysql.Config&#123;<br>DSN: dsn,<br>&#125;),<br>&amp;gorm.Config&#123;<br>Logger: myLogger, <span class="hljs-comment">// 这里传入自定义的logger</span><br>&#125;,<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>table := &amp;Test&#123;&#125;<br><span class="hljs-keyword">if</span> !db.Migrator().HasTable(table) &#123;<br>err = db.AutoMigrate(table)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建test表成功&quot;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>table.Text = <span class="hljs-string">&quot;text&quot;</span><br>err = db.Create(table).Error<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;插入成功&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 输出示例(执行时表已存在)：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2022/03/05 10:59:55 /Users/xxx/go/pkg/mod/gorm.io/driver/mysql@v1.3.2/migrator.go:228</span><br><span class="hljs-comment">[0.128ms] [rows:-] SELECT DATABASE()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2022/03/05 10:59:55 /Users/xxx/go/pkg/mod/gorm.io/driver/mysql@v1.3.2/migrator.go:231</span><br><span class="hljs-comment">[1.251ms] [rows:1] SELECT SCHEMA_NAME from Information_schema.SCHEMATA where SCHEMA_NAME LIKE &#x27;gorm_test%&#x27; ORDER BY SCHEMA_NAME=&#x27;gorm_test&#x27; DESC limit 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2022/03/05 10:59:55 /Users/xxx/GoProjects/gorm-test/main.go:56</span><br><span class="hljs-comment">[0.295ms] [rows:-] SELECT count(*) FROM information_schema.tables WHERE table_schema = &#x27;gorm_test&#x27; AND table_name = &#x27;tests&#x27; AND table_type = &#x27;BASE TABLE&#x27;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2022/03/05 10:59:55 /Users/xxx/GoProjects/gorm-test/main.go:65</span><br><span class="hljs-comment">[0.877ms] [rows:1] INSERT INTO `tests` (`text`) VALUES (&#x27;text&#x27;)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.bilibili.com/video/BV1E64y1472a">B站奇淼 - GORM V2</a></li><li><a href="https://gorm.io/zh_CN/">GORM官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Test</title>
    <link href="/posts/44be1998/"/>
    <url>/posts/44be1998/</url>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><a href="https://pkg.go.dev/testing">testing</a>包为<code>Go</code>包的自动化测试提供支持。它旨在与<code>go test</code>命令配合使用，使如下格式的函数自动执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestXxx</span><span class="hljs-params">(t *testing.T)</span></span><br></code></pre></td></tr></table></figure><p>其中<code>Xxx</code>不能以小写字母开头。函数名用以标志要被测试的函数。</p><p>在这些函数中，使用<code>Error</code>、<code>Fail</code>或类似的方法来表示失败。</p><p>要编写一个新的测试流，创建一个以<code>_test.go</code>结尾的文件，其中包含<code>TestXxx</code>格式的测试函数。将该文件放在与被测试函数所在文件相同的包中。普通包<code>build</code>时会将此类测试文件排除，但在执行<code>go test</code>命令时将会包含此类文件。更多详情，请执行<code>go help test</code>和<code>go help testflag</code>查看。</p><p>一个简单的测试case：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    got := Abs(<span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">if</span> got != <span class="hljs-number">1</span> &#123;<br>        t.Errorf(<span class="hljs-string">&quot;Abs(-1) = %d; want 1&quot;</span>, got)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基准测试-Benchmark"><a href="#基准测试-Benchmark" class="headerlink" title="基准测试(Benchmark)"></a>基准测试(Benchmark)</h2><p><code>func BenchmarkXxx(*testing.B)</code>格式的函数将被视为基准测试，当执行<code>go test</code>命令并带有<code>-bench</code>标志时将执行此类函数。基准测试是按顺序执行的。</p><p>更多测试标志请查看<a href="https://pkg.go.dev/cmd/go#hdr-Testing_flags">Testing flags</a>。</p><p>一个简单的基准测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkRandInt</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>        rand.Int()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基准测试函数将运行<code>b.N</code>次。在基准测试执行期间，将会动态的调整<code>b.N</code>的值，直到基准测试函数执行的时间足够长且结果稳定可靠。输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BenchmarkRandInt</span>-<span class="hljs-number">8</span>   <span class="hljs-number">68453040</span>        <span class="hljs-number">17</span>.<span class="hljs-number">8</span> ns/op<br></code></pre></td></tr></table></figure><p>表示该循环执行了68453040次，每次执行耗时17.8 ns。</p><p>如果基准测试在运行前需要一些比较重的初始化，那么可以将计时器重置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBigLen</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>    big := NewBig()<br>    b.ResetTimer() <span class="hljs-comment">// 重置计时器</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>        big.Len()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要以并行的方式来进行基准测试，可以使用辅助汗水<code>RunParallel</code>。这种基准测试旨在与<code>go test -cpu</code>标志一起使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkTemplateParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>    templ := template.Must(template.New(<span class="hljs-string">&quot;test&quot;</span>).Parse(<span class="hljs-string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))<br>    b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> buf bytes.Buffer<br>        <span class="hljs-keyword">for</span> pb.Next() &#123;<br>            buf.Reset()<br>            templ.Execute(&amp;buf, <span class="hljs-string">&quot;World&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>该包也可以运行并验证<code>example code</code>。<code>example</code>函数可以包含以”Output:”为前缀的结论性注释，并且在测试函数运行时与标准输出进行比较。（比较时会忽略行收尾的空格）下面是一些示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleHello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    <span class="hljs-comment">// Output: hello</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleSalutations</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello, and&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;goodbye&quot;</span>)<br>    <span class="hljs-comment">// Output:</span><br>    <span class="hljs-comment">// hello, and</span><br>    <span class="hljs-comment">// goodbye</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以”Unordered output:”为前缀的注视与”Output:”类似，只是任何顺序都将匹配。</p><p>没有输出注释的<code>Example</code>函数只会被编译但不会执行。</p><p>对于包、函数<code>F</code>、类型<code>T</code>或类型<code>T</code>的方法<code>M</code>对应的<code>examples</code>的命名约定是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Example</span><span class="hljs-params">()</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleF</span><span class="hljs-params">()</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleT</span><span class="hljs-params">()</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleT_M</span><span class="hljs-params">()</span></span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h2 id="跳过-Skipping"><a href="#跳过-Skipping" class="headerlink" title="跳过(Skipping)"></a>跳过(Skipping)</h2><p>可以在运行时通过调用<code>*T</code>或<code>*B</code>的<code>Skip</code>方法跳过单元测试或基准测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestTimeConsuming</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> testing.Short() &#123;<br>        t.Skip(<span class="hljs-string">&quot;skipping test in short mode.&quot;</span>)<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子单元测试和子基准测试"><a href="#子单元测试和子基准测试" class="headerlink" title="子单元测试和子基准测试"></a>子单元测试和子基准测试</h2><h2 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h2><p>有时需要在单元测试或基准测试执行之前执行一些额外的初始化或之后执行一些清理工作。有时也需要来控制哪些代码在主线程执行。为了支持这些情况，如果一个测试文件包含函数<code>func TestMain(m *testing.M)</code>，那么在执行测试时将调用该函数而不是直接运行单元测试或基准测试。<code>TestMain</code>在主协程中执行并且可以在调用<code>m.Run</code>前后执行必要的初始化或清理工作。<code>m.Run</code>将会返回一个退出码，可以将其传给<code>os.Exit</code>。</p><p>当<code>TestMain</code>被调用时，<code>flag.Parse</code>还未被运行。如果<code>TestMain</code>依赖命令行的标志，包括那么测试包，那么应该显式的调用<code>flag.Parse</code>。命令行标志总是在单元测试或基准测试运行时解析。</p><p>一个<code>TestMain</code>的简单实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMain</span><span class="hljs-params">(m *testing.M)</span></span> &#123;<br><span class="hljs-comment">// call flag.Parse() here if TestMain uses flags</span><br>os.Exit(m.Run())<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TestMain</code>是一个低级原语，当普通测试函数满足需求时不应该使用。</p><p>示例：</p><p><code>calc.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sub</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125;<br></code></pre></td></tr></table></figure><p><code>calc_test.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;begin TestAdd&quot;</span>)<br>r := Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> r != <span class="hljs-number">3</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;Add(1, 2) failed. Got %d, expected 3.&quot;</span>, r)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;end TestAdd&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSub</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;begin TestSub&quot;</span>)<br>r := Sub(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> r != <span class="hljs-number">8</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;Sub(10, 2) failed. Got %d, expected 8.&quot;</span>, r)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;end TestSub&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMain</span><span class="hljs-params">(m *testing.M)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;begin&quot;</span>)<br>m.Run()<br>fmt.Println(<span class="hljs-string">&quot;end&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/posts/44be1998/TestMain.jpg" class="" title="TestMain测试结果"><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://pkg.go.dev/testing">testing</a></li><li><a href="https://www.kancloud.cn/golang_programe/golang/1173356">TestMain</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ安装与入门</title>
    <link href="/posts/f6150876/"/>
    <url>/posts/f6150876/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>macOS</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install rabbitmq<br></code></pre></td></tr></table></figure><p>然后把<code>/usr/local/sbin</code>加入环境变量。比如在<code>~/.zshrc</code>文件末尾加入<code>export PATH=$PATH:/usr/local/sbin</code>，然后执行<code>source ~/.zshrc</code>命令来重新加载。</p><h1 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h1><p>前台启动：<code>rabbitmq-server</code></p><p>后台启动：<code>rabbitmq-server -detached</code></p><p>停止服务：<code>rabbitmqctl shutdown</code></p><p>PS：启动后可以访问<code>http://localhost:15672/</code>进入web管理页面，默认的<code>Username</code>是<code>guest</code>，<code>Password</code>也是<code>guest</code>。</p><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><ul><li>rabbitmqctl：用于进行服务管理和一些普通操作任务；</li><li>rabbitmq-diagnostics：用于诊断和健康检查；</li><li>rabbitmq-plugins：用于管理插件；</li><li>rabbitmq-queues：用于维护队列中的任务，尤其是<code>Quorum</code>队列；</li><li>rabbitmq-upgrade：用于维护与升级相关的任务；</li><li>rabbitmqadmin：用于通过HTTP接口操作任务。</li></ul><p>这些工具都可以在<code>/usr/local/sbin</code>中找到，也都可以通过<code>命令 help</code>查看对应命令的详细使用。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul><li>VirtualHost：用于进行数据隔离、区分队列、隔离账号。</li><li>Connection</li><li>Exchange</li><li>Channel</li><li>Queue</li><li>Binding：将Queue绑定到某个Exchange上。</li></ul><h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><h2 id="Simple模式"><a href="#Simple模式" class="headerlink" title="Simple模式"></a>Simple模式</h2><img src="/posts/f6150876/simple.png" class="" title="Simple模式"><ul><li>P：生产者（publisher）</li><li>红色部分：队列</li><li>C：消费者（Consumer）</li></ul><p>获取Go语言的客户端库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get -u github.com/streadway/amqp<br></code></pre></td></tr></table></figure><p>示例代码：</p><p>目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── consumer.go<br>├── go.mod<br>├── go.sum<br>├── mq<br>│   └── mq.go<br>└── publisher.go<br><br>1 directory, 5 files<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mq<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/streadway/amqp&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>MQURL = <span class="hljs-string">&quot;amqp://imoocuser:imoocuser@127.0.0.1:5672/imooc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> RabbitMQ <span class="hljs-keyword">struct</span> &#123;<br>conn      *amqp.Connection<br>channel   *amqp.Channel<br>QueueName <span class="hljs-type">string</span> <span class="hljs-comment">// 队列名称</span><br>Exchange  <span class="hljs-type">string</span><br>Key       <span class="hljs-type">string</span><br>mqURL     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// NewRabbitMQ 创建mq实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRabbitMQ</span><span class="hljs-params">(queueName, exchange, key <span class="hljs-type">string</span>)</span></span> *RabbitMQ &#123;<br>rabbitMQ := &amp;RabbitMQ&#123;<br>QueueName: queueName,<br>Exchange:  exchange,<br>Key:       key,<br>mqURL:     MQURL,<br>&#125;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>rabbitMQ.conn, err = amqp.Dial(rabbitMQ.mqURL)<br>rabbitMQ.failOnError(err, <span class="hljs-string">&quot;创建连接失败！&quot;</span>)<br>rabbitMQ.channel, err = rabbitMQ.conn.Channel()<br>rabbitMQ.failOnError(err, <span class="hljs-string">&quot;获取channel失败！&quot;</span>)<br><span class="hljs-keyword">return</span> rabbitMQ<br>&#125;<br><br><span class="hljs-comment">// Destroy 断开连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *RabbitMQ)</span></span> Destroy() &#123;<br>r.channel.Close()<br>r.conn.Close()<br>&#125;<br><br><span class="hljs-comment">// 错误处理</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *RabbitMQ)</span></span> failOnError(err <span class="hljs-type">error</span>, message <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%s:%s&quot;</span>, message, err)<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;%s:%s&quot;</span>, message, err))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// NewRabbitMQSimple 创建simple模式的mq实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRabbitMQSimple</span><span class="hljs-params">(queueName <span class="hljs-type">string</span>)</span></span> *RabbitMQ &#123;<br><span class="hljs-keyword">return</span> NewRabbitMQ(queueName, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// simple模式 生产</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *RabbitMQ)</span></span> PublishSimple(message <span class="hljs-type">string</span>) &#123;<br><span class="hljs-comment">// 1. 申请队列，不存在时自动创建，存在时则跳过创建</span><br>_, err := r.channel.QueueDeclare(<br>r.QueueName,<br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否持久化</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 最后一个连接断开时是否自动删除</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否具有排他性，true时当前创建的队列其他用户不可见</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否阻塞</span><br><span class="hljs-literal">nil</span>,<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><span class="hljs-comment">// 2.发送消息到队列中</span><br>err = r.channel.Publish(<br>r.Exchange,<br><span class="hljs-comment">// r.Key,</span><br>r.QueueName,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        []<span class="hljs-type">byte</span>(message),<br>&#125;,<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *RabbitMQ)</span></span> ConsumeSimple() &#123;<br><span class="hljs-comment">// 1. 申请队列，不存在时自动创建，存在时则跳过创建</span><br>_, err := r.channel.QueueDeclare(<br>r.QueueName,<br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否持久化</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 最后一个连接断开时是否自动删除</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否具有排他性，true时当前创建的队列其他用户不可见</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否阻塞</span><br><span class="hljs-literal">nil</span>,<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>msgs, err := r.channel.Consume(<br>r.QueueName,<br><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 用于区分多个消费者</span><br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>, <span class="hljs-comment">// true:表示不能将同一个connection中发送的消息传递给这个connection中的消费者</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 队列消费是否阻塞</span><br><span class="hljs-literal">nil</span>,<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>forever := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> msgs &#123;<br><span class="hljs-comment">// 处理消息的业务代码</span><br>log.Printf(<span class="hljs-string">&quot;接收到消息： %s\n&quot;</span>, <span class="hljs-type">string</span>(msg.Body))<br>&#125;<br>&#125;()<br>log.Printf(<span class="hljs-string">&quot;等待接收消息中...\n&quot;</span>)<br>&lt;-forever<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;rabbitmq-demo/mq&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mq := mq.NewRabbitMQSimple(<span class="hljs-string">&quot;imoocSimple&quot;</span>)<br>mq.PublishSimple(<span class="hljs-string">&quot;Hello imooc!&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;发送成功！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;rabbitmq-demo/mq&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mq := mq.NewRabbitMQSimple(<span class="hljs-string">&quot;imoocSimple&quot;</span>)<br>mq.ConsumeSimple()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工作模式（Work-Queues）"><a href="#工作模式（Work-Queues）" class="headerlink" title="工作模式（Work Queues）"></a>工作模式（Work Queues）</h2><img src="/posts/f6150876/work_queues.png" class="" title="Work Queues"><p>从上图可以明显的看出，工作模式与Simple模式的区别就是消费者可以有多个(但是每条消息只能被一个消费者消费)。</p><p>适用场景：生产消息的速度过快，Simple模式的单个消费者无法及时处理全部消息。</p><h2 id="发布-x2F-订阅模式"><a href="#发布-x2F-订阅模式" class="headerlink" title="发布&#x2F;订阅模式"></a>发布&#x2F;订阅模式</h2><img src="/posts/f6150876/pub_sub.png" class="" title="发布订阅模式"><p>其中<code>X</code>表示<code>Exchange</code>。</p><p>特点：消息被<code>Exchange</code>投递到多个队列，一条消息可以被多个消费者消费。</p><p><code>RabbitMQ</code>的消息模型中的核心思想是，生产者从来不直接将消息投递到队列中。实际上，生产者通常根本不知道消息是否被投递到任何队列中。</p><p>取而代之的是，生产者只能将消息投递到<code>exchange</code>中。<code>exchange</code>是一个非常简单的东西。一方面它接收来自生产者的消息，另一方面将消息推送到队列中。<code>exchange</code>必须明确的知道如何处理它收到的消息。是否要追加到某个特定的队列中？是否要追加到多个队列中？或者是否要将其丢弃？这些规则都由<code>exchange</code>的类型来定义。</p><p>可用的<code>exchange</code>类型有：<code>direct</code>、<code>topic</code>、<code>headers</code>、<code>fanout</code>。发布&#x2F;订阅模式使用的是<code>fanout</code>类型。</p><p><code>fanout</code>类型的<code>exchange</code>非常简单。从它的名字就能猜出来，它就是将它收到的所有消息广播给它已知的所有队列。</p><p>测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRabbitMQPubSub</span><span class="hljs-params">(exchangeName <span class="hljs-type">string</span>)</span></span> *RabbitMQ &#123;<br><span class="hljs-keyword">return</span> NewRabbitMQ(<span class="hljs-string">&quot;&quot;</span>, exchangeName, <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// PubSubPublish 发布订阅模式 生产消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *RabbitMQ)</span></span> PubSubPublish(message <span class="hljs-type">string</span>) &#123;<br><span class="hljs-comment">// 1. 尝试创建Exchange，不存在时自动创建，存在则跳过创建</span><br>err := r.channel.ExchangeDeclare(<br>r.Exchange,<br>amqp.ExchangeFanout,<br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;声明Exchange失败！&quot;</span>)<br><span class="hljs-comment">// 2. 发布消息</span><br>err = r.channel.Publish(<br>r.Exchange,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        []<span class="hljs-type">byte</span>(message),<br>&#125;,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;发布消息失败！&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// PubSubConsume 发布订阅模式 消费消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *RabbitMQ)</span></span> PubSubConsume(exchangeName <span class="hljs-type">string</span>) &#123;<br><span class="hljs-comment">// 1. 声明Exchange</span><br>err := r.channel.ExchangeDeclare(<br>r.Exchange,<br>amqp.ExchangeFanout,<br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;声明Exchange失败！&quot;</span>)<br><span class="hljs-comment">// 2. 声明队列</span><br>q, err := r.channel.QueueDeclare(<br><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 随机生成队列名称</span><br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;声明队列失败！&quot;</span>)<br><span class="hljs-comment">// 3. 绑定队列到Exchange</span><br>err = r.channel.QueueBind(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br>r.Exchange,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;绑定队列失败！&quot;</span>)<br><span class="hljs-comment">// 4. 消费消息</span><br>msgs, err := r.channel.Consume(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;消费消息失败！&quot;</span>)<br>forever := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> msgs &#123;<br>log.Printf(<span class="hljs-string">&quot;消费到消息：%s\n&quot;</span>, <span class="hljs-type">string</span>(msg.Body))<br>&#125;<br>&#125;()<br>&lt;-forever<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mq<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>pubsubExchangeName = <span class="hljs-string">&quot;pubsubExchange&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPubSubConsume</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mq := NewRabbitMQPubSub(pubsubExchangeName)<br>mq2 := NewRabbitMQPubSub(pubsubExchangeName)<br>wg := sync.WaitGroup&#123;&#125;<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>fmt.Println(<span class="hljs-string">&quot;启动消费者1&quot;</span>)<br>mq.PubSubConsume(pubsubExchangeName)<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>fmt.Println(<span class="hljs-string">&quot;启动消费者2&quot;</span>)<br>mq2.PubSubConsume(pubsubExchangeName)<br>&#125;()<br>wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPubSubPublish</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mq := NewRabbitMQPubSub(pubsubExchangeName)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>mq.PubSubPublish(fmt.Sprintf(<span class="hljs-string">&quot;message %d&quot;</span>, i))<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行消费者测试：<code>go test -run ^TestPubSubConsume$</code></p><p>执行生产者测试：<code>go test -run ^TestPubSubPublish$</code></p><p>运行结果：</p><img src="/posts/f6150876/pubsub_test.jpg" class="" title="pubsub测试"><h2 id="路由-Routing-模式"><a href="#路由-Routing-模式" class="headerlink" title="路由(Routing)模式"></a>路由(Routing)模式</h2><p>一条消息可以被多个消费者获取，并且消息的目标队列可以被生产者指定。</p><p>路由模式使用的<code>exchange</code>类型是<code>direct</code>。这种类型对应的路由算法非常简单：只将消息发送到绑定key与<code>exchange</code>的路由key相同的队列中，没有匹配队列的消息将被丢弃。</p><img src="/posts/f6150876/routing.png" class="" title="routing模式"><p>测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRabbitMQRouting</span><span class="hljs-params">(exchangeName, routingKey <span class="hljs-type">string</span>)</span></span> *RabbitMQ &#123;<br>mq := NewRabbitMQ(<span class="hljs-string">&quot;&quot;</span>, exchangeName, routingKey)<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>mq.conn, err = amqp.Dial(mq.mqURL)<br>mq.failOnError(err, <span class="hljs-string">&quot;Dial failed!&quot;</span>)<br>mq.channel, err = mq.conn.Channel()<br>mq.failOnError(err, <span class="hljs-string">&quot;get channel failed!&quot;</span>)<br><span class="hljs-keyword">return</span> mq<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *RabbitMQ)</span></span> RoutingPublish(message <span class="hljs-type">string</span>) &#123;<br>err := r.channel.ExchangeDeclare(<br>r.Exchange,<br>amqp.ExchangeDirect,<br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;声明Exchange失败！&quot;</span>)<br><br>err = r.channel.Publish(<br>r.Exchange,<br>r.Key,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        []<span class="hljs-type">byte</span>(message),<br>&#125;,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;发布消息失败！&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *RabbitMQ)</span></span> RoutingConsume() &#123;<br>err := r.channel.ExchangeDeclare(<br>r.Exchange,<br>amqp.ExchangeDirect,<br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;声明Exchange失败！&quot;</span>)<br>q, err := r.channel.QueueDeclare(<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;声明队列失败！&quot;</span>)<br>err = r.channel.QueueBind(<br>q.Name,<br>r.Key,<br>r.Exchange,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;绑定队列失败！&quot;</span>)<br>msgs, err := r.channel.Consume(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-literal">true</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>r.failOnError(err, <span class="hljs-string">&quot;消费消息失败！&quot;</span>)<br>forever := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> msgs &#123;<br>log.Printf(<span class="hljs-string">&quot;[%s]消费到消息：%s&quot;</span>, q.Name, msg.Body)<br>&#125;<br>&#125;()<br>&lt;-forever<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestRoutingConsume</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>mq := NewRabbitMQRouting(routingExchangeName, routingKey1)<br>mq.RoutingConsume()<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>mq := NewRabbitMQRouting(routingExchangeName, routingKey2)<br>mq.RoutingConsume()<br>&#125;()<br>wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestRoutingPublish</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>mq := NewRabbitMQRouting(routingExchangeName, routingKey1)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>mq.RoutingPublish(fmt.Sprintf(<span class="hljs-string">&quot;message from routing1 publisher: %d&quot;</span>, i))<br>time.Sleep(time.Second)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>mq := NewRabbitMQRouting(routingExchangeName, routingKey2)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>mq.RoutingPublish(fmt.Sprintf(<span class="hljs-string">&quot;message from routing2 publisher: %d&quot;</span>, i))<br>time.Sleep(time.Second)<br>&#125;<br>&#125;()<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><h2 id="Topic模式"><a href="#Topic模式" class="headerlink" title="Topic模式"></a>Topic模式</h2><p>路由模式仍然有限制：不能基于多个标准进行路由。所以有了<code>Topic</code>模式。</p><p>一条消息被多个消费者获取。消息的目标queue可以用BindingKey以通配符(#:匹配一个或多个词；*:匹配一个词)的方式指定。</p><p>发送到<code>topic</code>类型的<code>exchange</code>中的消息不能是任意的<code>routing_key</code>，必须是一个由点号(<code>.</code>)分割的单词列表。比如：<code>stock.usd.nyse</code>、<code>nyse.vmw</code>、<code>quick.orange.rabbit</code>。<code>rouuting_key</code>包含的单词数量不限，只要key的大小不超过255字节即可。</p><p><code>binding key</code>必须使用相同的格式。不过有两个特殊case：</p><ul><li><code>*</code>：可以匹配一个任意单词；</li><li><code>#</code>：可以匹配任意个(&gt;&#x3D;0)单词。</li></ul><img src="/posts/f6150876/topics.png" class="" title="Topic模式"><p>代码：TODO</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.rabbitmq.com/install-homebrew.html">安装</a></li><li><a href="https://www.rabbitmq.com/install-generic-unix.html#operations">操作</a></li><li><a href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html">Hello World! - Go</a></li><li><a href="https://www.rabbitmq.com/tutorials/tutorial-two-go.html">Work Queues - Go</a></li><li><a href="https://www.rabbitmq.com/tutorials/tutorial-three-go.html">Publish&#x2F;Subscribe - Go</a></li><li><a href="https://www.rabbitmq.com/tutorials/tutorial-four-go.html">Routing - Go</a></li><li><a href="https://www.rabbitmq.com/tutorials/tutorial-five-go.html">Topics - Go</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25. K 个一组翻转链表</title>
    <link href="/posts/290cb30/"/>
    <url>/posts/290cb30/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>模拟即可，k个节点作为一个子链表，从前往后依次翻转。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 增加一个虚拟头节点方便后续操作</span><br>virtualHead := &amp;ListNode&#123;<br>Next: head,<br>&#125;<br>pre := virtualHead <span class="hljs-comment">// 表示当前正在操作的子链表前边那个链表的尾节点</span><br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>tail := pre<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123; <span class="hljs-comment">// 走k步</span><br>tail = tail.Next<br><span class="hljs-keyword">if</span> tail == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> virtualHead.Next<br>&#125;<br>&#125;<br>next := tail.Next<br>tail.Next = <span class="hljs-literal">nil</span><br>head, tail = reverseLink(head) <span class="hljs-comment">// 翻转子链表</span><br>pre.Next = head<br>tail.Next = next<br>pre = tail<br>head = next<br>&#125;<br><span class="hljs-keyword">return</span> virtualHead.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseLink</span><span class="hljs-params">(head *ListNode)</span></span> (*ListNode, *ListNode) &#123;<br>tail := head<br><span class="hljs-keyword">var</span> pre *ListNode<br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>next := head.Next<br>head.Next = pre<br>pre = head<br>head = next<br>&#125;<br><span class="hljs-keyword">return</span> pre, tail<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：O(n)，其中<code>n</code>为链表的长度，操作过程过程中每个节点都会访问到，并进行<code>O(n/k)</code>(向下取整)次翻转操作。</p><p>空间复杂度：O(1)，需要几个额外的指针辅助操作。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该解法的一个技巧点在于构造一个虚拟的头节点简化操作，其余的只要指针的修改正确就没问题了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>917. 仅仅反转字母</title>
    <link href="/posts/d02199dd/"/>
    <url>/posts/d02199dd/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-only-letters/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>思路：首尾两两交换，使用双指针的技巧分别从前、后向中间移动，在两个指针都指向字符的时候进行交换。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    arr := []<span class="hljs-type">rune</span>(s)<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        <span class="hljs-keyword">for</span> left &lt; right &amp;&amp; !unicode.IsLetter(arr[left]) &#123;<br>            left++<br>        &#125;<br>        <span class="hljs-keyword">for</span> right &gt; left &amp;&amp; !unicode.IsLetter(arr[right]) &#123;<br>            right--<br>        &#125;<br>        <span class="hljs-keyword">if</span> left &gt;= right &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        arr[left], arr[right] = arr[right], arr[left]<br>        left++<br>        right--<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(arr)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该题主要考察对数组的处理，以及使用双指针同时维护两个处理对象的技巧。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>237. 删除链表中的节点</title>
    <link href="/posts/f39532f/"/>
    <url>/posts/f39532f/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/submissions/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>由于拿不到头节点，所以只能根据当前节点向后遍历，所以可以采用后向前覆盖的思想，将要删除节点的值改为后面节点的值，然后删除后面的节点即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 由于题目给定了一些限制，所以这里就不考虑边界条件了</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(node *ListNode)</span></span> &#123;<br>    node.Val = node.Next.Val<br>    next := node.Next<br>    node.Next = next.Next<br>    next.Next = <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：O(1)</p><p>空间复杂度：O(1)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该题的关键点在于要能想到通过后面的节点向前覆盖的方法来实现删除的效果。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>206. 反转链表</title>
    <link href="/posts/7787fb56/"/>
    <url>/posts/7787fb56/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>假设链表是：<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nil</code>，那么其反转后的链表等价于<code>1&lt;-reverseList(2-&gt;3-&gt;4-&gt;5-&gt;nil)</code>，因此可以使用递归依次处理链表的一部分，不过在完成反转链表<code>reverseList(2-&gt;3-&gt;4-&gt;5-&gt;nil)</code>后初步得到的链表是<code>1-&gt;2&lt;-3&lt;-4&lt;-5</code>，所以还需要将节点<code>2</code>的<code>next</code>指针指向节点<code>1</code>，而此时reverseList返回后当前节点是<code>1</code>（因为是在访问节点<code>1</code>的时候调用的<code>reverseList(1.Next)</code>），所以只需要做<code>head.Next.Next=head</code>即可完成将<code>2.Next</code>指向<code>1</code>，最后在将该节点的<code>next</code>指针执行<code>nil</code>即可解决。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    newHead := reverseList(head.Next)<br>    head.Next.Next = head<br>    head.Next = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">return</span> newHead<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：O(n)。</p><p>空间复杂度：O(n)，主要是递归占用的栈空间。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>上面的解法当规模<code>n</code>比较大的时候会占用比较多的栈空间，下面看一下翻转链表的直观操作步骤是怎样的：</p><p>反转链表主要就是对每个节点<code>next</code>指针的修改，比如对于链表<code>a-&gt;b-&gt;c</code>，处理步骤为：先修改节点<code>b</code>的<code>next</code>指针指向<code>a</code>（因为只能从前往后顺序遍历链表），但是修改了节点<code>b</code>的<code>next</code>指针就无法取得节点<code>c</code>的指针了，所以需要提前保存节点<code>b</code>前后节点的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 迭代</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    <span class="hljs-keyword">var</span> pre *ListNode<br>    cur := head<br>    next := cur.Next<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next = cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该题主要考察对链表的操作，要注意在修改指针指向的时候不要出现空指针问题和环。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>198. 打家劫舍</title>
    <link href="/posts/3bd407/"/>
    <url>/posts/3bd407/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>当偷到第<code>n</code>家的时候有两个选择：偷或不偷，如果偷，那么可以获得的最高金额为<code>f(n-2)+nums[n]</code>；如果不偷，那么可以获得的最高金额为<code>f(n-1)</code>，所以<code>f(n)=max(f(n-2)+nums[n],f(n-1))</code>即为递推方程，然后基础条件<code>f(1)</code>和<code>f(2)</code>很容易求出，那么就可以套用动态规划的框架进行求解了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>&#125;<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>dp[i] = max(dp[i<span class="hljs-number">-2</span>]+nums[i], dp[i<span class="hljs-number">-1</span>])<br>&#125;<br><span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>由于求解时只与前两个状态值有关，那么可以使用滚动数组对空间复杂度进行优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>&#125;<br>a := nums[<span class="hljs-number">0</span>]<br>b := max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>a, b = b, max(a+nums[i], b)<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="寻找其他解法"><a href="#寻找其他解法" class="headerlink" title="寻找其他解法"></a>寻找其他解法</h1><p>暂无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>找到要求解的问题与子问题之间的关系是求解动态规划类题目的关键所在。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>滚动数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>746. 使用最小花费爬楼梯</title>
    <link href="/posts/4eac4b9f/"/>
    <url>/posts/4eac4b9f/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>思路1:由于每一步都是在做选择（支付完花费后走一步还是两步），所以尝试用回溯来解决。</p><p>思路2:假设到达第<code>n</code>级楼梯需要的花费为<code>f(n)</code>，由于到达第<code>n</code>级楼梯的方式有两种：1.从第<code>n-1</code>级上一级；2.从第<code>n-2</code>级上两级。所以可以推出<code>f(n)=f(n-1)+cost[i-1]</code>或<code>f(n)=f(n-2)+cost[n-2]</code>，最终取二者中的较小值即可。(如果这两个值相等则取哪个都可以)所以递推方程为<code>f(n)=min(f(n-1)+cost[i-1],f(n-2)+cost[n-2])</code>，因此可以通过此方程递归求解。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>递归实现(会超时)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> f(cost, <span class="hljs-built_in">len</span>(cost))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> min(f(cost, i<span class="hljs-number">-1</span>)+cost[i<span class="hljs-number">-1</span>], f(cost, i<span class="hljs-number">-2</span>)+cost[i<span class="hljs-number">-2</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &lt;= b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(2^n)</p><p>空间复杂度：不考虑递归时堆栈占用的空间的话是O(1)</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>使用dp数组优化重复的计算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(cost)<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>dp[i] = min(dp[i<span class="hljs-number">-1</span>]+cost[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-2</span>])<br>&#125;<br><span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &lt;= b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p>由于当前值只与前两个值有关，所以可以使用滚动数组对空间复杂度进行优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(cost)<br>a, b := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>a, b = b, min(a+cost[i<span class="hljs-number">-2</span>], b+cost[i<span class="hljs-number">-1</span>])<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &lt;= b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题不难找出递推方程，比较关键的一点在于<code>dp[0]</code>和<code>dp[1]</code>为0，有了这些信息再通过套用动态规划的框架即可解决。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>滚动数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="/posts/fc2b22fc/"/>
    <url>/posts/fc2b22fc/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/climbing-stairs/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>思路：当级数为<code>n</code>的时候，假设已知<code>n-1</code>级时有<code>x</code>种，<code>n-2</code>级时为<code>y</code>，那么<code>f(n)=f(n-1)+f(n-2)</code>为递推方程，且显然<code>f(1)=1</code>,<code>f(2)=2</code>为base case，那么就可以自底向上递推出最终的<code>f(n)</code>。</p><p>Q：为什么<code>f(n)=f(n-1)+f(n-2)</code>是正确的？</p><p>A：因为上到第<code>n</code>级的方式有两种：1.从第<code>n-1</code>级再上一级；2.从第<code>n-2</code>级一次上两级；而到达第<code>n-1</code>和<code>n-2</code>级分别有<code>f(n-1)</code>和<code>f(n-2)</code>种方法，所以<code>f(n)=f(n-1)+f(n-2)</code>是正确的。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>a, b := <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123; <span class="hljs-comment">// 自底向上递推</span><br>a, b = b, a+b<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>无</p><h1 id="寻找其他解法"><a href="#寻找其他解法" class="headerlink" title="寻找其他解法"></a>寻找其他解法</h1><p>TODO：由于每一步都是在做选择，选择走一步还是两步，所以感觉也可以用回溯来解决。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题的关键在于找到最终问题与子问题之间的关系和递推方程，有了递推方程就很容易用动态规划来实现了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>717. 1比特与2比特字符</title>
    <link href="/posts/13333127/"/>
    <url>/posts/13333127/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>思路：遍历数组，如果当前值是0，属于第一种字符，如果当前不是最后一个字符，跳过，如果是最后一个，返回true；如果当前字符是1，说明当前字符和下一个字符组成第二种字符（因为题目说明了数组一定以0结尾，所以1后面肯定还有字符），跳过当前字符和下一个字符。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isOneBitCharacter</span><span class="hljs-params">(bits []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(bits)<br><span class="hljs-keyword">for</span> i &lt; n &#123;<br><span class="hljs-keyword">switch</span> bits[i] &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-keyword">if</span> i == n<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>i += <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：O(n)，一次遍历即可。</p><p>空间复杂度：O(1)</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>无</p><h1 id="寻找其他解法"><a href="#寻找其他解法" class="headerlink" title="寻找其他解法"></a>寻找其他解法</h1><p>无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该题主要考察对数组的理解和处理，比较简单。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>969. 煎饼排序</title>
    <link href="/posts/9b4b413b/"/>
    <url>/posts/9b4b413b/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/pancake-sorting/">原题传送门</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>该题中有一个比较重要的提示：</p><blockquote><p><code>arr</code>中的所有整数互不相同（即，<code>arr</code>是从<code>1</code>到<code>arr.length</code>整数的一个排列）</p></blockquote><p>并且，每次翻转只能翻转前<code>k</code>个数。</p><p>所以初步有一个思路是：</p><p>从后往前依次找对应位置的数，如果该位置的数在该位置则可以直接跳过处理它前面的；如果该位置的数在首位，那么可以直接翻转到该位置；如果该位置的数不在首位，那么需要先找到该位置的数在哪，然后翻转到首位，然后再翻转到目标位置。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pancakeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> n := <span class="hljs-built_in">len</span>(arr); n &gt; <span class="hljs-number">1</span>; n-- &#123;<br>index := <span class="hljs-number">0</span> <span class="hljs-comment">// 记录前n个中最大值的索引</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr[:n] &#123;<br><span class="hljs-keyword">if</span> v &gt; arr[index] &#123;<br>index = i<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> index == n<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, index; i &lt; j; i++ &#123;<br>arr[i], arr[j] = arr[j], arr[i]<br>j--<br>&#125;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>; i &lt; j; i++ &#123;<br>arr[i], arr[j] = arr[j], arr[i]<br>j--<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, index+<span class="hljs-number">1</span>, n)<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：遍历arr为O(n)，每次遍历中的翻转为O(n)，所以是O(n^2)。</p><p>空间复杂度：O(1)，只有一个记录当前前k个中最大值的索引index，返回值res的空间不计。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>TODO</p><h1 id="寻找其他解法"><a href="#寻找其他解法" class="headerlink" title="寻找其他解法"></a>寻找其他解法</h1><p>TODO</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基本思路还是比较容易想到的，但是实现起来还是要多想想，使用双指针进行翻转子数组时需要注意一下边界问题。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
